<!DOCTYPE html>
<html lang="pl">

	<head>
		<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1" />


	<title>Varnish Cache dla miękkich form inteligencji</title>


<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@rafalmakara" />
<meta name="twitter:title" content="Varnish Cache dla miękkich form inteligencji" />
<meta name="twitter:description" content="Wdrożenie z miękkiej perspektywy">

<meta name="description" content="Wdrożenie z miękkiej perspektywy">



<link type="application/atom+xml" rel="alternate" href="https://rmakara.github.io/feed.xml" title="Rafał Makara - Blog" />

<link rel="icon" href="/assets/favicon.png">
<link rel="apple-touch-icon" href="/assets/touch-icon.png">
<link href="https://fonts.googleapis.com/css?family=Karla" rel="stylesheet">
<link rel="stylesheet" href="/assets/core.css">
<link rel="canonical" href="/notes/Varnish-dla-miekkich-form-inteligencji">
<link rel="alternate" type="application/atom+xml" title="Rafał Makara - Blog" href="/feed.xml" />




<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
   
	</head>

	<body>

		<aside class="logo">
	

	<a href="/">
		<img src="http://www.gravatar.com/avatar/7d539859a7986a42e6d2c43c081826b7.png?s=80" class="gravatar">
	</a>
	<span class="logo-prompt">Wróć na Stronę Główną</span>
</aside>	


		<main>
			<article>

	<div class="center">
		<h1>Varnish Cache dla miękkich form inteligencji</h1>
		<time>2018-01-29</time>     
        <br /><br />
        
            #varnish
        
            #cache
        
            #tech
        
            #software
        
	</div>

	<div class="divider"></div>

	<h1 id="wdrożenie-z-miękkiej-perspektywy">Wdrożenie z miękkiej perspektywy</h1>

<p>Nigdy nie miałem okazji wdrażać Varnisha (ani innego web acceleratora czy reverse proxy) siedząc bezpośrednio przy kodzie. Jednak w ostatnim czasie przeszedłem przez cały proces implementacji rozwiązania z punktu widzenia project managera. Słownictwo wykorzystywane przez programistów podczas prac nad Varnishem zazwyczaj jest bardzo wysokopoziomowe, ponieważ zakłada, że menadżer i tak nie zrozumie szczegółów rozwiązania lub wręcz przeciwnie - jest bardzo techniczne i wtedy rzeczywiście PM nic z tego nie rozumie.</p>

<p>Poniższy artykuł ma na celu wyjaśnienie podstawowych pojęć związanych z Varnishem, aby osoby niebędące specialistami w tym zakresie były w stanie zrozumieć, o czym mówią programiści.</p>

<h1 id="web-accelerator-czy-reverse-proxy">Web accelerator czy Reverse proxy?</h1>

<p>Varnish jest zazwyczaj nazywany web acceleratorem lub reverse proxy. Skąd pochodzą te nazwy? Akceleracja sugeruje, że głównym zadaniem narzędzia jest przyśpieszanie działania strony. W najprostszym rozumieniu działania Varnisha można tak go określić. Varnish tworzy warstwę stojącą między użytkownikiem i serwerem aplikacyjnym (dla uproszczenia załóżmy, że mamy do czynienia z aplikacją monolityczną uruchomioną na jednym serwerze aplikacyjnym) i jego głównym zadaniem jest redukowanie obciążenia aplikacji przez cacheowanie powtarzalnych żądań, które następnie będzie można serwować użytkownikom bez odwoływania się do serwera aplikacyjnego.</p>

<p>Poza mechanizmem cacheowania dostarcza on szersze rozwiązania jak np. load balancing. Na potrzeby tego artykułu skupimy się jednak głównie na cache.</p>

<p>Aby zrozumieć pojęcie reverse proxy wyjaśnijmy w uproszczeniu, czym jest serwer proxy. Wyobraźmy sobie, że jesteśmy użytkownikiem Internetu, który chce włamać się na stronę banku internetowego. W celu ukrycia swojej tożsamości korzystamy z serwera proxy, który będzie pośredniczył w ruchu między nami i bankiem. Dzięki wykorzystaniu takiego pośrednika można powiedzieć, że “chowamy się” za nim i z punktu widzenia ofiary (banku) to serwer proxy włamuje się do banku, a nie my. Wysyłane przez nas żądanie trafia do serwera proxy, następnie do banku, odpowiedź zwracana jest do serwera proxy i na końcu do nas.</p>

<p>Reverse proxy to podobny mechanizm, ale stojący po drugiej stronie płotu. W tym wypadku to serwer (a nie użytkownik) “chowa się” za serwerem reverse proxy, który symuluje jego zachowanie. Z perspektywy użytkownika wysyłamy żądanie do naszej aplikacji, które tak naprawdę trafia do serwera reverse proxy. Ten serwer decyduje czy odpowie nam samodzielnie, czy przekaże nasze zapytanie do prawdziwego serwera aplikacyjnego.</p>

<h1 id="podstawowa-zasada-działania-cache-w-varnishu">Podstawowa zasada działania cache w Varnishu</h1>

<p>Proces wygląda następująco:</p>

<ul>
  <li>Użytkownik wchodzi na stronę internetową.</li>
  <li>Żądanie HTTP trafia do Varnisha:
    <ul>
      <li>Jeżeli Varnish posiada aktualny cache elementu, o który jest proszony to odsyła response użytkownikowi.</li>
      <li>Jeżeli Varnish nie posiada aktualnego cache elementu to przekazuje request do serwera aplikacyjnego i w dalszej kolejności zwraca odpowiedź użytkownikowi na podstawie danych otrzymanych od serwera aplikacyjnego.</li>
    </ul>
  </li>
</ul>

<h1 id="vcl-varnish-configuration-language">VCL, Varnish Configuration Language</h1>

<p>Językiem, w którym tworzymy konfigurację Varnisha jest VCL. W rozmowach z programistami określenie VCL często jest skrótem myślowym do określenia pliku konfiguracyjnego Varnisha. VCL pozwala nam na dostosowanie narzędzia do naszych potrzeb.</p>

<h1 id="czas-ważności-ttl-i-typ-cache">Czas ważności (TTL) i typ cache</h1>

<p>Podstawowym podziałem cacheowanych w Varnishu elementów jest rozdzielenie contentu statycznego od dynamicznego. Przykładem contentu statycznego może być logo firmy, które zazwyczaj jest niezmienne. Przykładem contentu dynamicznego może być wielkie zdjęcie obrazujące stan magazynowy towaru w sklepie internetowym, które jest aktualizowane co 30 minut.</p>

<p>Dla dwóch powyższych typów zawartości strony możemy zdefiniować czasy TTL (time-to-live), które określą czas ważności cache liczony od momentu jego utworzenia. Przykładowo, określamy TTL na 60 minut. Jeżeli wejdziemy na stronę internetową to bazując na naszej wizycie jej cache zostanie stworzony w Varnishu i wszyscy kolejni użytkownicy wchodzący na tą samą stronę w ciągu najbliższych 60 minut otrzymają zawartość strony bardzo szybko, ponieważ odpowiedź zostanie przygotowana w warstwie reverse proxy, bez wykorzystania serwera aplikacyjnego. Umożliwia nam to bardzo szybkie pokazanie strony internetowej użytkownikowi, ale generuje ryzyko, że w ciągu tych 60 minut strona w serwerze aplikacyjnym zostanie zaktualizowana - wtedy użytkownicy będą otrzymywać nieaktualną wersję strony, aż do zakończenia czasu TTL.</p>

<p>Parametrem mówiącym o wieku danego elementu cache jest Age, który przedstawia nam wartość w postaci ilości sekund - od chwili utworzenia cache, do teraz. Gdy Age zrówna się z TTL - cache uznawany jest za nieaktualny.</p>

<h1 id="grace-time">Grace Time</h1>

<p>Czas “ważności” cache można w awaryjnych sytuacjach wydłużyć. Varnish od wersji 4 pozwala na zdefiniowanie tak zwanego czasu Grace Time. Określa on czas ponad TTL w ciągu którego możemy pogodzić się z odpowiedzią użytkownikowi nieaktualną zcacheowaną wersją strony, gdy napotkamy problem z uzyskaniem odpowiedzi od serwera aplikacyjnego.</p>

<p>Przykładem zastosowania grace time może być sytuacja, w której czas ważności cache konkretnej strony minął, użytkownik przesyła request o daną stronę, z poziomu Varnisha okazuje się że serwer aplikacyjny jest niedostępny lub bardzo obciążony, Varnish sprawdza grace time danego elementu i jeżeli konfiguracja pozwala nam na pogodzenie się z faktem nieaktualnej odpowiedzi to Varnish odpowiada użytkownikowi.</p>

<p>Równolegle do przeprowadzania tej operacji, Varnish jest w stanie zainicjować proces odświeżający pamięć podręczną danego elementu, aby została ona zaktualizowana w osobnym wątku na potrzeby przyszłych użytkowników.</p>

<h1 id="health-check">Health check</h1>

<p>W celu określenia wydajności działania backendu oraz podjęcia decyzji o wykorzystaniu grace time Varnish pozwala na wykonywanie health checków. Sposób ich działania jest samoopisujący się przez poniższy kod pochodzący z dokumentacji Varnisha.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>backend server1 {
  .host = "server1.example.com";
  .probe = {
         .url = "/";
         .interval = 5s;
         .timeout = 1 s;
         .window = 5;
         .threshold = 3;
    }
  }
</code></pre></div></div>

<h1 id="automat-skończony-finite-state-machine">Automat skończony (finite state machine)</h1>

<p>W celu rozwiązania wcześniej przedstawionego problemu możliwej nieaktualności pamięci podręcznej musimy zrozumieć stany, jakie występują w Varnishu, który bywa nazywany skończoną maszyną stanów / automatem skończonym / finite state machine.</p>

<p>Stany można rozumieć jako sposób obsłużenia danego żądania HTTP, które trafia do Varnisha. Podstawowe z nich to:</p>
<ul>
  <li><code class="highlighter-rouge">miss</code> - Żądanie od użytkownika przechodząc przez Varnish szukało i nie znalazło zcacheowanej wersji elementu, którego potrzebowało. W takiej sytuacji konieczne jest odwołanie się do z aplikacji.</li>
  <li><code class="highlighter-rouge">pass</code> - Żądanie nie szukało wersji zcacheowanej, a jedynie “przeszło” przez Varnisha prosto do aplikacji. W momencie zwracania odpowiedzi również nie jest ono cacheowane.</li>
  <li><code class="highlighter-rouge">hit</code> - Żądanie znalazło aktualny cache w Varnishu. Pobiera element z cache i zwraca odpowiedź użytkownikowi. Nie obciąża aplikacji.</li>
  <li><code class="highlighter-rouge">hit_for_pass</code> - Typ akcji, który mówi o tym, że Varnish to nie tylko warstwa cache, a także mądre oprogramowanie stanowiące firewall stojący przed aplikacją. <code class="highlighter-rouge">hit_for_pass</code> to działanie, przy którym w cache nie znajduje się zcacheowany obiekt i inicjuje ono pobranie go z aplikacji. Oznacza jednak dane żądanie jako “w trakcie pobierania” i dzięki temu inni użytkownicy aplikacji, którzy zapytają o to samo nie generują kolejnych żądań odwołania do backendu, a czekają w warstwie reverse proxy, aż to jedno dojdzie z aplikacji do Varnisha. Dzięki temu, w przypadku 1000 użytkowników pytających o to samo przekazujemy 1 żądanie do aplikacji, 999 żądań czeka w Varnishu. Gdy odpowiedź wróci do Varnisha z backendu - otrzyma ją 1000 użytkowników.</li>
  <li><code class="highlighter-rouge">waiting</code> - Akcja określająca, że żądanie użytkownika czeka na aktualizację wynikającą z innego żądania <code class="highlighter-rouge">hit_for_pass</code>.</li>
</ul>

<p>Kompletną lista stanów i wyjaśnienie ich zadania warto przestudiować w rozdziałach <a href="https://book.varnish-software.com/4.0/chapters/VCL_Basics.html">VCL Basics</a> oraz <a href="https://varnish-cache.org/docs/trunk/users-guide/vcl-built-in-subs.html.">Build in subroutines</a> zawartych w oficjalnej dokumentacji.</p>

<h1 id="inwalidacja-cache">Inwalidacja cache</h1>

<blockquote>
  <p>There are 2 hard problems in computer science: cache invalidation, naming things, and off-by-1 errors.</p>

  <p>– <cite>Phil Karlton (edited by: Leon Bambrick)</cite></p>
</blockquote>

<p>Większość systemów nie opiera się jedynie na samym odczytywaniu danych, a pozwala dodatkowo na ich modyfikację. Programista implementujący rozwiązanie jest w stanie wyznaczyć operacje, które powinny natychmiastowo wymuszać wyczyszczenie cache. Przykładem może być aktualizacja nazwy produktu w sklepie internetowym. Załóżmy, że nasza strona produktowa jest na tyle niezmienna, że cacheujemy ją w pełni. Pewnego dnia, administrator sklepu aktualizuje nazwę produktu. W związku z tym, użytkownicy wchodzący na omawianą stronę powinni zobaczyć jego nową nazwę. W tym celu programista po zapisaniu produktu w panelu administracyjnym może wyczyścić dane elementy cache omawianej strony produktowej i tym samym wymusić załadowanie nowej zawartości strony wprost z serwera aplikacyjnego.</p>

<p>Do przeprowadzania powyższych operacji korzystamy z dwóch typów żądań. Pierwsze z nich to <code class="highlighter-rouge">purge</code>, który pozwala nam na wyczyszczenie pamięci podręcznej konkretnego adresu URL / elementu. Wywoływany jest on podobnie do typowych requestów HTTP GET. Drugim typem żądania jest <code class="highlighter-rouge">ban</code>, który na podstawie wskazanego wyrażenia regularnego może nam pomóc z wyczyszczeniem cache wielu stron / elementów. Ban może również zostać wywołany podobnie do requestu HTTP, ale domyślnym momentem jego uruchamiania jest moment trafienia w cache (<code class="highlighter-rouge">hit</code>).</p>

<h1 id="edge-side-includes">Edge Side Includes</h1>

<p>W celu zoptymalizowania procesu inwalidacji cache możemy wykorzystać mechanizm ESI. Pozwala on na wyznaczenie w obrębie strony konkretnych elementów, które nie powinny być cacheowane. Przykładowo, decydujemy się trzymać w cache całą stronę karty produktu, ale zauważamy na niej dwa elementy, które często się zmieniają - cena oraz stan magazynowy. Te dwa elementy możemy otoczyć blokami ESI. Doprowadzi to do sytuacji, w której będziemy mieli zachowaną w pamięci podręcznej całą stronę, a o te dwa wskazane elementy każdorazowo będziemy odpytywać serwer aplikacyjny - dzięki temu one zawsze będa aktualne, a pozostała zawartość strony będzie ładować się bardzo szybko. W efekcie nie musimy inwalidować cache tej strony.</p>

<h1 id="monitorowanie-efektów">Monitorowanie efektów</h1>

<p>Po wdrożeniu Varnisha z pewnością chcielibyśmy zmierzyć efekty płynące z faktu jego zaimplementowania. Należy pamiętać, że popularne oprogramowania monitorujące lub profilujące (jak np. New Relic) są spięte zazwyczaj z serwerem aplikacyjnym. Przykładowo, w przypadku pracy z językiem PHP nasze oprogramowanie może analizować pracę PHP-FPM. Varnish znajduje na warstwie bliższej użytkownikowi, w związku z czym nie zaobserwujemy efektów jego pracy w New Relicu, a dostrzeżemy jedynie zmniejszony ruch na serwerze aplikacyjnym.</p>

<p>Efekty pracy Varnisha możemy zaobserwować np. przez cykliczne uruchamianie testów symulujących klikanie użytkownika  internetowej według wskazanych scenariuszy. Przez wyciągnięcie czasów średnich ładowania poszczególnych stron w okresie przed i po wdrożeniu Varnisha powinniśmy móc zauważyć różnicę.</p>

<h1 id="podsumowanie">Podsumowanie</h1>

<p>Reverse proxy nie takie straszne jak je malują. Dzięki tego typu narzędziom możemy przyśpieszyć działanie strony internetowej i poprawić doświadczenia użytkowników. To wszystko przy dość niewielkim koszcie wdrożenia. W skrajnych przypadkach możemy wykorzystać tego typu rozwiązanie do zamaskowania niewydolności backendu spowodowanej naszymi własnymi błedami… wróć… błędami tych legendarnych, innych programistów (sic!).</p>

<p>Oryginalna dokumentacja Varnisha została napisana w bardzo przyjazny sposób i w pełni zachęcam do jej lektury.</p>

<hr />

<h4 id="źródła-i-pojęcia">Źródła i pojęcia</h4>

<ul>
  <li>[1] <a href="https://varnish-cache.org/docs/trunk/index.html">Varnish Documentation, https:/varnish-cache.com</a></li>
  <li>[2] <a href="https://book.varnish-software.com/4.0/chapters/VCL_Basics.html">VCL Basics, https://book.varnish-software.com</a></li>
  <li>[3] <a href="https://varnish-cache.org/docs/trunk/users-guide/vcl-built-in-subs.html">Built in subroutines, https:/varnish-cache.com</a></li>
  <li>[4] <a href="http://varnish-cache.org/trac/wiki/VCLExampleGrace">Grace, https:/varnish-cache.com</a></li>
  <li>[5] <a href="https://varnish-cache.org/docs/3.0/tutorial/purging.html">Purging &amp; banning, https:/varnish-cache.com</a></li>
</ul>


	<div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'rmakara-github-io'; // required: replace example with your forum shortname
        //var disqus_developer = 1; // Comment out when the site is live
        var disqus_identifier = "/notes/Varnish-dla-miekkich-form-inteligencji";

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</article>

<div class="page-navigation">
	
		<a class="home" href="/" title="Wróć na Stronę Główną">Wróć na Stronę Główną</a>
  
		<span> &middot; </span>
    <a class="prev" href="/notes/Ksiazki-i-najlepszy-prezent-materialny-w-2017" title="Poprzedni: Książki i najlepszy prezent materialny w 2017">&gt;&gt;</a>
  
</div>

		</main>

		<div class="footer">
  <p class="rss-subscribe"><a href="/newsletter">Subskrybuj Newsletter</a></p>
  <p class="rss-subscribe"><a href="/feed.xml">Subskrybuj RSS</a></p>

  <span class="block">Made with &hearts; using <a href="http://jekyllrb.com/">Jekyll</a> &amp; <a href="https://github.com/heiswayi/the-plain" title="The Plain theme by Heiswayi Nrird">The Plain</a> &middot; &lt;/&gt; on <a href="https://github.com/rmakara" title="Hosted on GitHub">GitHub</a></span>
  <span class="block">&copy; 2018 Rafał Makara</span>
</div>

	    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-92815270-1', 'auto');
  ga('send', 'pageview');
</script>

	</body>

</html>
